{"version":3,"names":["clamp","value","min","Number","MIN_SAFE_INTEGER","max","MAX_SAFE_INTEGER","Math","bqSliderCss","BqSliderStyle0","BqSlider","proxyCustomElement","H","inputMinElem","inputMaxElem","minTooltipElem","maxTooltipElem","progressElem","trackElem","debounceBqChange","internals","minValue","maxValue","minThumbPosition","maxThumbPosition","debounceTime","disabled","enableValueIndicator","gap","name","step","type","enableTooltip","tooltipAlwaysVisible","handleValuePropChange","newValue","this","setState","emitBqChange","handleStepPropChange","round","handleGapChange","isRangeType","isNil","stringToObject","bqChange","bqBlur","bqFocus","componentWillLoad","init","componentDidLoad","runUpdates","componentDidUpdate","formAssociatedCallback","setFormValue","updateProgressTrack","syncInputsValue","setThumbPosition","thumbPosition","setAttribute","toString","isString","JSON","parse","handleInputChange","event","target","parseFloat","reflectedValue","stringify","calculatePercent","totalRange","left","width","style","insetInlineStart","inlineSize","calculateThumbPosition","trackAreaWidth","getBoundingClientRect","inputThumbSize","parseInt","getComputedStyle","el","getPropertyValue","totalWidth","undefined","cancel","debounce","emit","handleBlur","handleFocus","handleMouseDown","handleTooltipVisibility","handleMouseUp","action","tooltipElem","classList","decimalCount","toFixed","split","replace","length","isTooltipAlwaysVisible","renderLabel","position","css","h","class","hidden","part","renderInput","refCallback","zIndexValue","zIndex","ref","onInput","ev","onBlur","onFocus","onMouseDown","onMouseUp","renderTooltip","exportparts","alwaysVisible","distance","fontVariant","slot","render","key","elem","input"],"sources":["../../packages/beeq/src/shared/utils/clamp.ts","../../packages/beeq/src/components/slider/scss/bq-slider.scss?tag=bq-slider&encapsulation=shadow","../../packages/beeq/src/components/slider/bq-slider.tsx"],"sourcesContent":["/**\n * Restricts value to a specified interval [min, max]\n *\n * @param value - value\n * @param min  - lower end of the interval\n * @param max  - upper end of the interval\n * @returns  - value in interval [min, max]\n */\nexport const clamp = (value: number, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER) => {\n  return Math.min(Math.max(min, value), max);\n};\n","/* -------------------------------------------------------------------------- */\n/*                               Slider styles                                */\n/* -------------------------------------------------------------------------- */\n\n@import './bq-slider.variables';\n\n@layer components {\n  .thumb {\n    @apply pointer-events-auto box-content size-[--bq-slider--thumb-size] cursor-pointer appearance-none rounded-full border-m border-solid border-brand bg-ui-primary;\n    @apply transition-[background-color,border-color,box-shadow] duration-300;\n  }\n\n  .thumb-focus {\n    @apply focus;\n  }\n\n  .thumb-hover {\n    @apply border-hover-brand;\n  }\n\n  .thumb-active {\n    @apply cursor-grabbing bg-active-ui-brand border-active-brand;\n  }\n}\n\n:host {\n  @apply block is-full;\n}\n\n/* ---------------------- Webkit (Chrome, Safari, Edge) --------------------- */\n\ninput[type='range']::-webkit-slider-thumb {\n  @apply thumb;\n}\n\ninput[type='range']::-webkit-slider-runnable-track {\n  @apply transition-all duration-300 ease-in;\n}\n\ninput[type='range']:focus-visible::-webkit-slider-thumb {\n  @apply thumb-focus;\n}\n\ninput[type='range']:hover::-webkit-slider-thumb {\n  @apply thumb-hover;\n}\n\ninput[type='range']:active::-webkit-slider-thumb {\n  @apply thumb-active;\n}\n\ninput[type='range'][disabled]::-webkit-slider-thumb {\n  @apply cursor-not-allowed;\n}\n\n/* ---------------------------- Mozilla (Firefox) --------------------------- */\n\ninput[type='range']::-moz-range-thumb {\n  @apply thumb;\n}\n\ninput[type='range']::-moz-range-track {\n  @apply transition-all duration-300 ease-in;\n}\n\ninput[type='range']:focus-visible::-moz-range-thumb {\n  @apply thumb-focus;\n}\n\ninput[type='range']:hover::-moz-range-thumb {\n  @apply thumb-hover;\n}\n\ninput[type='range']:active::-moz-range-thumb {\n  @apply thumb-active;\n}\n\ninput[type='range'][disabled]::-moz-range-thumb {\n  @apply cursor-not-allowed;\n}\n","import { AttachInternals, Component, Element, Event, EventEmitter, h, Prop, State, Watch } from '@stencil/core';\n\nimport { TSliderType, TSliderValue } from './bq-slider.types';\nimport { clamp, debounce, isNil, isString, TDebounce } from '../../shared/utils';\n\n/**\n * Sliders provide a visual representation of adjustable content, enabling users to change values by dragging a handle along a horizontal track.\n *\n * @example How to use it\n * ```html\n * <bq-slider max=\"100\" value=\"30\"></bq-slider>\n * ```\n *\n * @documentation https://www.beeq.design/3d466e231/p/509cbc-slider/b/09d7b1\n * @status stable\n *\n * @dependency bq-tooltip\n *\n * @attr {number} debounce-time - The amount of time, in milliseconds, to wait to trigger the bqChange event after each value change.\n * @attr {boolean} disabled - If `true` the slider is disabled.\n * @attr {boolean} enable-tooltip - If `true`, a tooltip will be shown displaying the progress value.\n * @attr {boolean} enable-value-indicator - If `true` it will show the value label on the side of the slider track area.\n * @attr {number} gap - A number representing the amount to remain between the minimum and maximum values (only for range type).\n * @attr {number} max - A number representing the max value of the slider.\n * @attr {number} min - A number representing the min value of the slider.\n * @attr {number} step - A number represents the step of the slider. ⚠️ Please notice that the value (or list of values if the slider type is range) will be rounded to the nearest multiple of step.\n * @attr {boolean} tooltip-always-visible - If `true`, a tooltip will always display the progress value. It relies on enableTooltip and if enableTooltip is false, tooltipAlwaysVisible cannot be true.\n * @attr {\"range\" | \"single\"} type - It defines the type of slider to display.\n * @attr {\"[number, number]\" | \"number\" | \"string\"} value - The value of the slider. If the slider type is single, the value is a number.\n * If the slider type is range, the value is an array of two numbers (the first number represents the min value and the second number represents the max value).\n *\n * @event bqBlur - Handler to be called when the slider loses focus.\n * @event bqChange - Handler to be called when changing the value on range inputs.\n * @event bqFocus - Handler to be called when the slider gets focused.\n *\n * @part base - The component's base wrapper.\n * @part container - The container of the slider.\n * @part track-area - The track area of the slider.\n * @part progress-area - The progress area of the slider.\n * @part input-min - The input element for the value when the slider type is `single` or the minimum value when the slider type is `range`.\n * @part input-max - The input element for the maximum value.\n * @part label-start - The label for the value when the slider type is `single` or the minimum value when the slider type is `range`.\n * @part label-end - The label for maximum value when the slider type is `range`.\n *\n * @cssprop --bq-slider--size - The height of the slider track/progress area\n * @cssprop --bq-slider--border-radius - Slider border radius\n * @cssprop --bq-slider--thumb-size - Slider hover thumb size\n * @cssprop --bq-slider--progress-color - Slider progress background color\n * @cssprop --bq-slider--trackarea-color - Slider track background color\n */\n@Component({\n  tag: 'bq-slider',\n  styleUrl: './scss/bq-slider.scss',\n  formAssociated: true,\n  shadow: {\n    delegatesFocus: true,\n  },\n})\nexport class BqSlider {\n  // Own Properties\n  // ====================\n\n  private inputMinElem: HTMLInputElement;\n  private inputMaxElem: HTMLInputElement;\n  private minTooltipElem: HTMLBqTooltipElement;\n  private maxTooltipElem: HTMLBqTooltipElement;\n  private progressElem: HTMLSpanElement;\n  private trackElem: HTMLSpanElement;\n  private debounceBqChange: TDebounce<void>;\n\n  // Reference to host HTML element\n  // ===================================\n\n  @AttachInternals() internals!: ElementInternals;\n  @Element() el!: HTMLBqSliderElement;\n\n  // State() variables\n  // Inlined decorator, alphabetical order\n  // =======================================\n\n  /**\n   * The `minValue` state is the only value when the slider type is `single`\n   * and the minimum value when the slider type is `range`.\n   */\n  @State() minValue: number;\n  /** The `maxValue` state is only used when the slider type is `range`. */\n  @State() maxValue: number;\n  /** It hold the left position of the Thumb for the value or the minimum value (if the slider type is `range`) */\n  @State() minThumbPosition: number;\n  /** It hold the left position of the Thumb for the maximum value (if the slider type is `range`) */\n  @State() maxThumbPosition: number;\n\n  // Public Property API\n  // ========================\n\n  /** The amount of time, in milliseconds, to wait to trigger the `bqChange` event after each value change. */\n  @Prop({ reflect: true }) debounceTime = 0;\n\n  /** If `true` the slider is disabled. */\n  @Prop({ reflect: true }) disabled? = false;\n\n  /** If `true` it will show the value label on a side of the slider track area */\n  @Prop({ reflect: true }) enableValueIndicator? = false;\n\n  /** A number representing the amount to remain between the minimum and maximum values (only for range type). */\n  @Prop({ reflect: true, mutable: true }) gap = 0;\n\n  /** A number representing the max value of the slider. */\n  @Prop({ reflect: true }) max = 100;\n\n  /** A number representing the min value of the slider. */\n  @Prop({ reflect: true }) min = 0;\n\n  /** Name of the form control. Submitted with the form as part of a name/value pair */\n  @Prop({ reflect: true }) name: string;\n\n  /**\n   * A number representing the step of the slider.\n   * ⚠️ Please notice that the value (or list of values if the slider type is `range`) will be rounded to the nearest multiple of `step`.\n   */\n  @Prop({ reflect: true }) step = 1;\n\n  /** It defines the type of slider to display  */\n  @Prop({ reflect: true }) type: TSliderType = 'single';\n\n  /**\n   * The value of the slider.\n   * - If the slider type is `single`, the value is a number.\n   * - If the slider type is `range`, the value is an array of two numbers (the first number represents the `min` value and the second number represents the `max` value).\n   */\n  @Prop({ reflect: true, mutable: true }) value: TSliderValue;\n\n  /** If `true`, a tooltip will be shown displaying the progress value */\n  @Prop({ reflect: true }) enableTooltip: boolean = false;\n\n  /**\n   * If `true`, a tooltip will always display the progress value.\n   * It relies on enableTooltip and if enableTooltip is false, tooltipAlwaysVisible cannot be true.\n   */\n  @Prop({ reflect: true }) tooltipAlwaysVisible: boolean = false;\n\n  // Prop lifecycle events\n  // =======================\n\n  @Watch('value')\n  handleValuePropChange(newValue: TSliderValue) {\n    this.setState(newValue);\n    this.emitBqChange();\n  }\n\n  @Watch('step')\n  handleStepPropChange() {\n    this.minValue = Math.round(this.minValue / this.step) * this.step;\n    this.maxValue = Math.round(this.maxValue / this.step) * this.step;\n  }\n\n  @Watch('gap')\n  handleGapChange(newValue: number) {\n    if (!this.isRangeType) return;\n    // Use the this.value prop value when the component is initialized\n    // Otherwise, use the current this.min and this.max state values\n    const value = !isNil(this.min) && !isNil(this.max) ? [this.min, this.max] : this.stringToObject(this.value);\n    // If the gap is less than the min or greater than the max, set it to 0\n    this.gap = newValue < value[0] || newValue > value[1] ? 0 : newValue;\n  }\n\n  // Events section\n  // Requires JSDocs for public API documentation\n  // ==============================================\n\n  /** Handler to be called when change the value on range inputs */\n  @Event() bqChange: EventEmitter<{ value: Exclude<TSliderValue, string>; el: HTMLBqSliderElement }>;\n\n  /** Handler to be called when the slider loses focus */\n  @Event() bqBlur: EventEmitter<HTMLBqSliderElement>;\n\n  /** Handler to be called when the slider gets focused */\n  @Event() bqFocus: EventEmitter<HTMLBqSliderElement>;\n\n  // Component lifecycle events\n  // Ordered by their natural call order\n  // =====================================\n\n  componentWillLoad() {\n    this.init();\n  }\n\n  componentDidLoad() {\n    this.runUpdates();\n  }\n\n  componentDidUpdate() {\n    this.runUpdates();\n  }\n\n  formAssociatedCallback() {\n    this.internals?.setFormValue(`${this.value}`);\n  }\n\n  // Listeners\n  // ==============\n\n  // Public methods API\n  // These methods are exposed on the host element.\n  // Always use two lines.\n  // Public Methods must be async.\n  // Requires JSDocs for public API documentation.\n  // ===============================================\n\n  // Local methods\n  // Internal business logic.\n  // These methods cannot be called from the host element.\n  // =======================================================\n\n  private init = () => {\n    this.handleGapChange(this.gap);\n    this.setState(this.value);\n    this.handleStepPropChange();\n  };\n\n  private runUpdates = () => {\n    this.updateProgressTrack();\n    this.syncInputsValue();\n    this.setThumbPosition();\n  };\n\n  private setState = (newValue: TSliderValue) => {\n    const isRangeType = this.isRangeType;\n    const value = this.stringToObject(newValue);\n\n    this.minValue = isRangeType ? clamp(value[0], this.min, this.max - this.gap) : value;\n    this.maxValue = isRangeType ? clamp(value[1], this.minValue + this.gap, this.max) : this.minValue;\n  };\n\n  private setThumbPosition = () => {\n    if (!this.enableTooltip) return;\n\n    // Destructure the returned object from this.thumbPosition() and assign the properties to this.minThumbPosition and this.maxThumbPosition\n    ({ minThumbPosition: this.minThumbPosition, maxThumbPosition: this.maxThumbPosition } = this.thumbPosition());\n  };\n\n  private syncInputsValue = () => {\n    this.inputMinElem?.setAttribute('value', this.minValue.toString());\n    this.inputMaxElem?.setAttribute('value', this.maxValue.toString());\n  };\n\n  private stringToObject = (value: TSliderValue) => (isString(value) ? JSON.parse(value) : value);\n\n  private handleInputChange = (type: 'min' | 'max', event: InputEvent) => {\n    const target = event.target as HTMLInputElement;\n    const value = parseFloat(target.value);\n\n    if (type === 'min') {\n      this.minValue = this.isRangeType ? Math.min(value, this.maxValue - this.gap) : value;\n    } else if (type === 'max') {\n      this.maxValue = this.isRangeType ? Math.max(value, this.minValue + this.gap) : value;\n    }\n\n    // Update the input value to reflect the clamped value\n    const reflectedValue = (type === 'min' ? this.minValue : this.maxValue).toString();\n    target.value = reflectedValue;\n    target.setAttribute('value', reflectedValue);\n\n    // Sync the prop value.\n    // This will trigger the `@Watch('value')` method and emit the `bqChange` event.\n    const { internals, isRangeType, maxValue, minValue } = this;\n    this.value = isRangeType ? [minValue, maxValue] : minValue;\n    internals?.setFormValue(isRangeType ? JSON.stringify(this.value) : this.value.toString());\n  };\n\n  private calculatePercent = (value: number) => {\n    const totalRange = Number(this.max) - Number(this.min);\n    return (value / totalRange) * 100;\n  };\n\n  private updateProgressTrack = () => {\n    if (!this.progressElem) return;\n\n    // For range type, left starts from the `min` value and width is the difference between `max` and `min`.\n    // For non-range type, left starts from 0 and width is the `min` value.\n    const left = this.isRangeType ? this.calculatePercent(this.minValue) : 0;\n    const width = this.isRangeType\n      ? this.calculatePercent(Number(this.maxValue) - Number(this.minValue))\n      : this.calculatePercent(this.minValue);\n\n    this.progressElem.style.insetInlineStart = `${left}%`;\n    this.progressElem.style.inlineSize = `${width}%`;\n  };\n\n  private calculateThumbPosition = (value: number): number => {\n    if (!this.progressElem) return;\n\n    // Get the width of the track area and the size of the input range thumb\n    const trackAreaWidth = this.trackElem.getBoundingClientRect().width;\n    // We need to also add 4px to the thumb size,\n    // this is because the thumb is 2px border (`border-m`)\n    const inputThumbSize = parseInt(getComputedStyle(this.el).getPropertyValue('--bq-slider--thumb-size'), 10) + 4;\n    const totalWidth = trackAreaWidth - inputThumbSize;\n\n    return ((value - this.min) / (this.max - this.min)) * totalWidth + inputThumbSize / 2;\n  };\n\n  private thumbPosition = (): { minThumbPosition: number; maxThumbPosition?: number } => {\n    const minThumbPosition = this.calculateThumbPosition(this.minValue);\n    const maxThumbPosition = this.isRangeType ? this.calculateThumbPosition(this.maxValue) : undefined;\n\n    return { minThumbPosition, maxThumbPosition };\n  };\n\n  private emitBqChange = () => {\n    this.debounceBqChange?.cancel();\n\n    const value: Exclude<TSliderValue, string> = this.isRangeType ? [this.minValue, this.maxValue] : this.minValue;\n    this.debounceBqChange = debounce(() => this.bqChange.emit({ value, el: this.el }), this.debounceTime);\n\n    this.debounceBqChange();\n  };\n\n  private handleBlur = () => {\n    this.bqBlur.emit(this.el);\n  };\n\n  private handleFocus = () => {\n    this.bqFocus.emit(this.el);\n  };\n\n  private handleMouseDown = (event: MouseEvent) => {\n    this.handleTooltipVisibility(event, 'remove');\n  };\n\n  private handleMouseUp = (event: MouseEvent) => {\n    this.handleTooltipVisibility(event, 'add');\n  };\n\n  private handleTooltipVisibility = (event: MouseEvent, action: 'add' | 'remove') => {\n    if (!this.enableTooltip || this.tooltipAlwaysVisible) return;\n\n    const target = event.target as HTMLElement;\n    const tooltipElem = target === this.inputMinElem ? this.minTooltipElem : this.maxTooltipElem;\n    tooltipElem.classList[action]('hidden');\n  };\n\n  private get decimalCount(): number {\n    // Return the length of the decimal part of the step value.\n    return (this.step % 1).toFixed(10).split('.')[1].replace(/0+$/, '').length;\n  }\n\n  private get isRangeType() {\n    return this.type === 'range';\n  }\n\n  private get isTooltipAlwaysVisible(): boolean {\n    return this.tooltipAlwaysVisible && this.enableTooltip;\n  }\n\n  private renderLabel = (value: number, position: 'start' | 'end', css?: string) => {\n    return (\n      <span\n        class={{\n          [`${css} box-content block text-s font-medium leading-regular text-primary is-fit min-is-8 [font-variant:tabular-nums]`]:\n            true,\n          hidden: position === 'start' ? !this.enableValueIndicator : !this.enableValueIndicator || !this.isRangeType,\n        }}\n        part={`label-${position}`}\n      >\n        {value.toFixed(this.decimalCount)}\n      </span>\n    );\n  };\n\n  private renderInput = (type: 'max' | 'min', value: number, refCallback: (input: HTMLInputElement) => void) => {\n    // Determine the zIndex value based on the type and the current min and max values.\n    const zIndexValue = (type: 'min' | 'max'): string => {\n      const zIndex = {\n        min: this.minValue === this.min && this.maxValue === this.minValue,\n        max: this.maxValue === this.max && this.minValue === this.maxValue,\n      };\n\n      // If the value of both thumbs is the same as the min or max value, set the zIndex to -1\n      return zIndex[type] ? '-1' : '0';\n    };\n\n    return (\n      <input\n        type=\"range\"\n        class={{\n          'absolute start-0 -translate-y-1/2 cursor-pointer appearance-none bg-transparent outline-none is-full inset-bs-[50%] disabled:cursor-not-allowed':\n            true,\n          'pointer-events-none': this.isRangeType,\n        }}\n        style={this.isRangeType ? { zIndex: zIndexValue(type) } : undefined}\n        disabled={this.disabled}\n        min={this.min}\n        max={this.max}\n        name={this.name}\n        step={this.step}\n        ref={refCallback}\n        onInput={(ev) => this.handleInputChange(type, ev)}\n        onBlur={this.handleBlur}\n        onFocus={this.handleFocus}\n        onMouseDown={this.handleMouseDown}\n        onMouseUp={this.handleMouseUp}\n        value={value}\n        part={`input-${type}`}\n      />\n    );\n  };\n\n  private renderTooltip = (\n    value: number,\n    thumbPosition: number,\n    refCallback: (elem: HTMLBqTooltipElement) => void,\n  ): HTMLBqTooltipElement => (\n    <bq-tooltip\n      class={{\n        'absolute [&::part(panel)]:absolute': true,\n        hidden: !this.isTooltipAlwaysVisible,\n      }}\n      exportparts=\"base,trigger,panel\"\n      alwaysVisible={true}\n      distance={this.enableValueIndicator ? 6 : 16}\n      style={{ insetInlineStart: `${thumbPosition}px`, fontVariant: 'tabular-nums' }}\n      ref={refCallback}\n    >\n      <div class=\"absolute bs-1 is-1\" slot=\"trigger\" />\n      {value.toFixed(this.decimalCount)}\n    </bq-tooltip>\n  );\n\n  // render() function\n  // Always the last one in the class.\n  // ===================================\n\n  render() {\n    return (\n      <div\n        aria-disabled={this.disabled ? 'true' : 'false'}\n        class={{ 'flex is-full': true, 'cursor-not-allowed opacity-60': this.disabled }}\n        part=\"base\"\n      >\n        {/* LABEL (start) */}\n        {this.renderLabel(this.minValue, 'start', 'me-xs text-end')}\n        {/* SLIDER */}\n        <div class=\"relative is-full\" part=\"container\">\n          {/* TRACK AREA */}\n          <span\n            class=\"absolute start-0 -translate-y-1/2 rounded-xs bg-[--bq-slider--trackarea-color] bs-1 is-full inset-bs-[50%]\"\n            ref={(elem) => (this.trackElem = elem)}\n            part=\"track-area\"\n          />\n          {/* PROGRESS AREA */}\n          <span\n            class=\"absolute -translate-y-1/2 rounded-xs bg-[--bq-slider--progress-color] bs-1 is-[50%] inset-bs-[50%]\"\n            ref={(elem) => (this.progressElem = elem)}\n            part=\"progress-area\"\n          />\n          {/* TOOLTIP on top of the value or min value (if the slider type is `range`) */}\n          {this.enableTooltip &&\n            this.renderTooltip(this.minValue, this.minThumbPosition, (elem) => (this.minTooltipElem = elem))}\n          {/* INPUT (Min), used on single type */}\n          {this.renderInput('min', this.minValue, (input) => (this.inputMinElem = input))}\n          {/* TOOLTIP on top of the max value (if the slider type is `range`) */}\n          {this.enableTooltip &&\n            this.isRangeType &&\n            this.renderTooltip(this.maxValue, this.maxThumbPosition, (elem) => (this.maxTooltipElem = elem))}\n          {/* INPUT (Max) */}\n          {this.isRangeType && this.renderInput('max', this.maxValue, (input) => (this.inputMaxElem = input))}\n        </div>\n        {/* LABEL (end) */}\n        {this.renderLabel(this.maxValue, 'end', 'ms-xs text-start')}\n      </div>\n    );\n  }\n}\n"],"mappings":";;;;kOAQaA,EAAQ,CAACC,EAAeC,EAAMC,OAAOC,iBAAkBC,EAAMF,OAAOG,mBACxEC,KAAKL,IAAIK,KAAKF,IAAIH,EAAKD,GAAQI,GCTxC,MAAMG,EAAc,oglCACpB,MAAAC,EAAeD,E,MCyDFE,EAAQC,EAAA,MAAAD,UAAAE,E,2MAIXC,aACAC,aACAC,eACAC,eACAC,aACAC,UACAC,iBAKWC,U,qBAWVC,SAEAC,SAEAC,iBAEAC,iBAMgBC,aAAe,EAGfC,SAAY,MAGZC,qBAAwB,MAGTC,IAAM,EAGrBvB,IAAM,IAGNH,IAAM,EAGN2B,KAMAC,KAAO,EAGPC,KAAoB,SAOL9B,MAGf+B,cAAyB,MAMzBC,qBAAgC,MAMzD,qBAAAC,CAAsBC,GACpBC,KAAKC,SAASF,GACdC,KAAKE,c,CAIP,oBAAAC,GACEH,KAAKf,SAAWd,KAAKiC,MAAMJ,KAAKf,SAAWe,KAAKN,MAAQM,KAAKN,KAC7DM,KAAKd,SAAWf,KAAKiC,MAAMJ,KAAKd,SAAWc,KAAKN,MAAQM,KAAKN,I,CAI/D,eAAAW,CAAgBN,GACd,IAAKC,KAAKM,YAAa,OAGvB,MAAMzC,GAAS0C,EAAMP,KAAKlC,OAASyC,EAAMP,KAAK/B,KAAO,CAAC+B,KAAKlC,IAAKkC,KAAK/B,KAAO+B,KAAKQ,eAAeR,KAAKnC,OAErGmC,KAAKR,IAAMO,EAAWlC,EAAM,IAAMkC,EAAWlC,EAAM,GAAK,EAAIkC,C,CAQrDU,SAGAC,OAGAC,QAMT,iBAAAC,GACEZ,KAAKa,M,CAGP,gBAAAC,GACEd,KAAKe,Y,CAGP,kBAAAC,GACEhB,KAAKe,Y,CAGP,sBAAAE,GACEjB,KAAKhB,WAAWkC,aAAa,GAAGlB,KAAKnC,Q,CAkB/BgD,KAAO,KACbb,KAAKK,gBAAgBL,KAAKR,KAC1BQ,KAAKC,SAASD,KAAKnC,OACnBmC,KAAKG,sBAAsB,EAGrBY,WAAa,KACnBf,KAAKmB,sBACLnB,KAAKoB,kBACLpB,KAAKqB,kBAAkB,EAGjBpB,SAAYF,IAClB,MAAMO,EAAcN,KAAKM,YACzB,MAAMzC,EAAQmC,KAAKQ,eAAeT,GAElCC,KAAKf,SAAWqB,EAAc1C,EAAMC,EAAM,GAAImC,KAAKlC,IAAKkC,KAAK/B,IAAM+B,KAAKR,KAAO3B,EAC/EmC,KAAKd,SAAWoB,EAAc1C,EAAMC,EAAM,GAAImC,KAAKf,SAAWe,KAAKR,IAAKQ,KAAK/B,KAAO+B,KAAKf,QAAQ,EAG3FoC,iBAAmB,KACzB,IAAKrB,KAAKJ,cAAe,SAGtBT,iBAAkBa,KAAKb,iBAAkBC,iBAAkBY,KAAKZ,kBAAqBY,KAAKsB,gBAAe,EAGtGF,gBAAkB,KACxBpB,KAAKvB,cAAc8C,aAAa,QAASvB,KAAKf,SAASuC,YACvDxB,KAAKtB,cAAc6C,aAAa,QAASvB,KAAKd,SAASsC,WAAW,EAG5DhB,eAAkB3C,GAAyB4D,EAAS5D,GAAS6D,KAAKC,MAAM9D,GAASA,EAEjF+D,kBAAoB,CAACjC,EAAqBkC,KAChD,MAAMC,EAASD,EAAMC,OACrB,MAAMjE,EAAQkE,WAAWD,EAAOjE,OAEhC,GAAI8B,IAAS,MAAO,CAClBK,KAAKf,SAAWe,KAAKM,YAAcnC,KAAKL,IAAID,EAAOmC,KAAKd,SAAWc,KAAKR,KAAO3B,C,MAC1E,GAAI8B,IAAS,MAAO,CACzBK,KAAKd,SAAWc,KAAKM,YAAcnC,KAAKF,IAAIJ,EAAOmC,KAAKf,SAAWe,KAAKR,KAAO3B,C,CAIjF,MAAMmE,GAAkBrC,IAAS,MAAQK,KAAKf,SAAWe,KAAKd,UAAUsC,WACxEM,EAAOjE,MAAQmE,EACfF,EAAOP,aAAa,QAASS,GAI7B,MAAMhD,UAAEA,EAASsB,YAAEA,EAAWpB,SAAEA,EAAQD,SAAEA,GAAae,KACvDA,KAAKnC,MAAQyC,EAAc,CAACrB,EAAUC,GAAYD,EAClDD,GAAWkC,aAAaZ,EAAcoB,KAAKO,UAAUjC,KAAKnC,OAASmC,KAAKnC,MAAM2D,WAAW,EAGnFU,iBAAoBrE,IAC1B,MAAMsE,EAAapE,OAAOiC,KAAK/B,KAAOF,OAAOiC,KAAKlC,KAClD,OAAQD,EAAQsE,EAAc,GAAG,EAG3BhB,oBAAsB,KAC5B,IAAKnB,KAAKnB,aAAc,OAIxB,MAAMuD,EAAOpC,KAAKM,YAAcN,KAAKkC,iBAAiBlC,KAAKf,UAAY,EACvE,MAAMoD,EAAQrC,KAAKM,YACfN,KAAKkC,iBAAiBnE,OAAOiC,KAAKd,UAAYnB,OAAOiC,KAAKf,WAC1De,KAAKkC,iBAAiBlC,KAAKf,UAE/Be,KAAKnB,aAAayD,MAAMC,iBAAmB,GAAGH,KAC9CpC,KAAKnB,aAAayD,MAAME,WAAa,GAAGH,IAAQ,EAG1CI,uBAA0B5E,IAChC,IAAKmC,KAAKnB,aAAc,OAGxB,MAAM6D,EAAiB1C,KAAKlB,UAAU6D,wBAAwBN,MAG9D,MAAMO,EAAiBC,SAASC,iBAAiB9C,KAAK+C,IAAIC,iBAAiB,2BAA4B,IAAM,EAC7G,MAAMC,EAAaP,EAAiBE,EAEpC,OAAS/E,EAAQmC,KAAKlC,MAAQkC,KAAK/B,IAAM+B,KAAKlC,KAAQmF,EAAaL,EAAiB,CAAC,EAG/EtB,cAAgB,KACtB,MAAMnC,EAAmBa,KAAKyC,uBAAuBzC,KAAKf,UAC1D,MAAMG,EAAmBY,KAAKM,YAAcN,KAAKyC,uBAAuBzC,KAAKd,UAAYgE,UAEzF,MAAO,CAAE/D,mBAAkBC,mBAAkB,EAGvCc,aAAe,KACrBF,KAAKjB,kBAAkBoE,SAEvB,MAAMtF,EAAuCmC,KAAKM,YAAc,CAACN,KAAKf,SAAUe,KAAKd,UAAYc,KAAKf,SACtGe,KAAKjB,iBAAmBqE,GAAS,IAAMpD,KAAKS,SAAS4C,KAAK,CAAExF,QAAOkF,GAAI/C,KAAK+C,MAAO/C,KAAKX,cAExFW,KAAKjB,kBAAkB,EAGjBuE,WAAa,KACnBtD,KAAKU,OAAO2C,KAAKrD,KAAK+C,GAAG,EAGnBQ,YAAc,KACpBvD,KAAKW,QAAQ0C,KAAKrD,KAAK+C,GAAG,EAGpBS,gBAAmB3B,IACzB7B,KAAKyD,wBAAwB5B,EAAO,SAAS,EAGvC6B,cAAiB7B,IACvB7B,KAAKyD,wBAAwB5B,EAAO,MAAM,EAGpC4B,wBAA0B,CAAC5B,EAAmB8B,KACpD,IAAK3D,KAAKJ,eAAiBI,KAAKH,qBAAsB,OAEtD,MAAMiC,EAASD,EAAMC,OACrB,MAAM8B,EAAc9B,IAAW9B,KAAKvB,aAAeuB,KAAKrB,eAAiBqB,KAAKpB,eAC9EgF,EAAYC,UAAUF,GAAQ,SAAS,EAGzC,gBAAYG,GAEV,OAAQ9D,KAAKN,KAAO,GAAGqE,QAAQ,IAAIC,MAAM,KAAK,GAAGC,QAAQ,MAAO,IAAIC,M,CAGtE,eAAY5D,GACV,OAAON,KAAKL,OAAS,O,CAGvB,0BAAYwE,GACV,OAAOnE,KAAKH,sBAAwBG,KAAKJ,a,CAGnCwE,YAAc,CAACvG,EAAewG,EAA2BC,IAE7DC,EAAA,QACEC,MAAO,CACL,CAAC,GAAGF,mHACF,KACFG,OAAQJ,IAAa,SAAWrE,KAAKT,sBAAwBS,KAAKT,uBAAyBS,KAAKM,aAElGoE,KAAM,SAASL,KAEdxG,EAAMkG,QAAQ/D,KAAK8D,eAKlBa,YAAc,CAAChF,EAAqB9B,EAAe+G,KAEzD,MAAMC,EAAelF,IACnB,MAAMmF,EAAS,CACbhH,IAAKkC,KAAKf,WAAae,KAAKlC,KAAOkC,KAAKd,WAAac,KAAKf,SAC1DhB,IAAK+B,KAAKd,WAAac,KAAK/B,KAAO+B,KAAKf,WAAae,KAAKd,UAI5D,OAAO4F,EAAOnF,GAAQ,KAAO,GAAG,EAGlC,OACE4E,EAAA,SACE5E,KAAK,QACL6E,MAAO,CACL,kJACE,KACF,sBAAuBxE,KAAKM,aAE9BgC,MAAOtC,KAAKM,YAAc,CAAEwE,OAAQD,EAAYlF,IAAUuD,UAC1D5D,SAAUU,KAAKV,SACfxB,IAAKkC,KAAKlC,IACVG,IAAK+B,KAAK/B,IACVwB,KAAMO,KAAKP,KACXC,KAAMM,KAAKN,KACXqF,IAAKH,EACLI,QAAUC,GAAOjF,KAAK4B,kBAAkBjC,EAAMsF,GAC9CC,OAAQlF,KAAKsD,WACb6B,QAASnF,KAAKuD,YACd6B,YAAapF,KAAKwD,gBAClB6B,UAAWrF,KAAK0D,cAChB7F,MAAOA,EACP6G,KAAM,SAAS/E,KACf,EAIE2F,cAAgB,CACtBzH,EACAyD,EACAsD,IAEAL,EAAA,cACEC,MAAO,CACL,qCAAsC,KACtCC,QAASzE,KAAKmE,wBAEhBoB,YAAY,qBACZC,cAAe,KACfC,SAAUzF,KAAKT,qBAAuB,EAAI,GAC1C+C,MAAO,CAAEC,iBAAkB,GAAGjB,MAAmBoE,YAAa,gBAC9DX,IAAKH,GAELL,EAAA,OAAKC,MAAM,qBAAqBmB,KAAK,YACpC9H,EAAMkG,QAAQ/D,KAAK8D,eAQxB,MAAA8B,GACE,OACErB,EAAA,OAAAsB,IAAA,2DACiB7F,KAAKV,SAAW,OAAS,QACxCkF,MAAO,CAAE,eAAgB,KAAM,gCAAiCxE,KAAKV,UACrEoF,KAAK,QAGJ1E,KAAKoE,YAAYpE,KAAKf,SAAU,QAAS,kBAE1CsF,EAAA,OAAAsB,IAAA,2CAAKrB,MAAM,mBAAmBE,KAAK,aAEjCH,EAAA,QAAAsB,IAAA,2CACErB,MAAM,6GACNO,IAAMe,GAAU9F,KAAKlB,UAAYgH,EACjCpB,KAAK,eAGPH,EAAA,QAAAsB,IAAA,2CACErB,MAAM,qGACNO,IAAMe,GAAU9F,KAAKnB,aAAeiH,EACpCpB,KAAK,kBAGN1E,KAAKJ,eACJI,KAAKsF,cAActF,KAAKf,SAAUe,KAAKb,kBAAmB2G,GAAU9F,KAAKrB,eAAiBmH,IAE3F9F,KAAK2E,YAAY,MAAO3E,KAAKf,UAAW8G,GAAW/F,KAAKvB,aAAesH,IAEvE/F,KAAKJ,eACJI,KAAKM,aACLN,KAAKsF,cAActF,KAAKd,SAAUc,KAAKZ,kBAAmB0G,GAAU9F,KAAKpB,eAAiBkH,IAE3F9F,KAAKM,aAAeN,KAAK2E,YAAY,MAAO3E,KAAKd,UAAW6G,GAAW/F,KAAKtB,aAAeqH,KAG7F/F,KAAKoE,YAAYpE,KAAKd,SAAU,MAAO,oB","ignoreList":[]}