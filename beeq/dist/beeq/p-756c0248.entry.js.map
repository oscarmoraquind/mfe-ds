{"version":3,"names":["bqSliderCss","BqSliderStyle0","BqSlider","inputMinElem","inputMaxElem","minTooltipElem","maxTooltipElem","progressElem","trackElem","debounceBqChange","internals","minValue","maxValue","minThumbPosition","maxThumbPosition","debounceTime","disabled","enableValueIndicator","gap","max","min","name","step","type","value","enableTooltip","tooltipAlwaysVisible","handleValuePropChange","newValue","this","setState","emitBqChange","handleStepPropChange","Math","round","handleGapChange","isRangeType","isNil","stringToObject","bqChange","bqBlur","bqFocus","componentWillLoad","init","componentDidLoad","runUpdates","componentDidUpdate","formAssociatedCallback","setFormValue","updateProgressTrack","syncInputsValue","setThumbPosition","clamp","thumbPosition","setAttribute","toString","isString","JSON","parse","handleInputChange","event","target","parseFloat","reflectedValue","stringify","calculatePercent","totalRange","Number","left","width","style","insetInlineStart","inlineSize","calculateThumbPosition","trackAreaWidth","getBoundingClientRect","inputThumbSize","parseInt","getComputedStyle","el","getPropertyValue","totalWidth","undefined","cancel","debounce","emit","handleBlur","handleFocus","handleMouseDown","handleTooltipVisibility","handleMouseUp","action","tooltipElem","classList","decimalCount","toFixed","split","replace","length","isTooltipAlwaysVisible","renderLabel","position","css","h","class","hidden","part","renderInput","refCallback","zIndexValue","zIndex","ref","onInput","ev","onBlur","onFocus","onMouseDown","onMouseUp","renderTooltip","exportparts","alwaysVisible","distance","fontVariant","slot","render","key","elem","input"],"sources":["../../packages/beeq/src/components/slider/scss/bq-slider.scss?tag=bq-slider&encapsulation=shadow","../../packages/beeq/src/components/slider/bq-slider.tsx"],"sourcesContent":["/* -------------------------------------------------------------------------- */\n/*                               Slider styles                                */\n/* -------------------------------------------------------------------------- */\n\n@import './bq-slider.variables';\n\n@layer components {\n  .thumb {\n    @apply pointer-events-auto box-content size-[--bq-slider--thumb-size] cursor-pointer appearance-none rounded-full border-m border-solid border-brand bg-ui-primary;\n    @apply transition-[background-color,border-color,box-shadow] duration-300;\n  }\n\n  .thumb-focus {\n    @apply focus;\n  }\n\n  .thumb-hover {\n    @apply border-hover-brand;\n  }\n\n  .thumb-active {\n    @apply cursor-grabbing bg-active-ui-brand border-active-brand;\n  }\n}\n\n:host {\n  @apply block is-full;\n}\n\n/* ---------------------- Webkit (Chrome, Safari, Edge) --------------------- */\n\ninput[type='range']::-webkit-slider-thumb {\n  @apply thumb;\n}\n\ninput[type='range']::-webkit-slider-runnable-track {\n  @apply transition-all duration-300 ease-in;\n}\n\ninput[type='range']:focus-visible::-webkit-slider-thumb {\n  @apply thumb-focus;\n}\n\ninput[type='range']:hover::-webkit-slider-thumb {\n  @apply thumb-hover;\n}\n\ninput[type='range']:active::-webkit-slider-thumb {\n  @apply thumb-active;\n}\n\ninput[type='range'][disabled]::-webkit-slider-thumb {\n  @apply cursor-not-allowed;\n}\n\n/* ---------------------------- Mozilla (Firefox) --------------------------- */\n\ninput[type='range']::-moz-range-thumb {\n  @apply thumb;\n}\n\ninput[type='range']::-moz-range-track {\n  @apply transition-all duration-300 ease-in;\n}\n\ninput[type='range']:focus-visible::-moz-range-thumb {\n  @apply thumb-focus;\n}\n\ninput[type='range']:hover::-moz-range-thumb {\n  @apply thumb-hover;\n}\n\ninput[type='range']:active::-moz-range-thumb {\n  @apply thumb-active;\n}\n\ninput[type='range'][disabled]::-moz-range-thumb {\n  @apply cursor-not-allowed;\n}\n","import { AttachInternals, Component, Element, Event, EventEmitter, h, Prop, State, Watch } from '@stencil/core';\n\nimport { TSliderType, TSliderValue } from './bq-slider.types';\nimport { clamp, debounce, isNil, isString, TDebounce } from '../../shared/utils';\n\n/**\n * Sliders provide a visual representation of adjustable content, enabling users to change values by dragging a handle along a horizontal track.\n *\n * @example How to use it\n * ```html\n * <bq-slider max=\"100\" value=\"30\"></bq-slider>\n * ```\n *\n * @documentation https://www.beeq.design/3d466e231/p/509cbc-slider/b/09d7b1\n * @status stable\n *\n * @dependency bq-tooltip\n *\n * @attr {number} debounce-time - The amount of time, in milliseconds, to wait to trigger the bqChange event after each value change.\n * @attr {boolean} disabled - If `true` the slider is disabled.\n * @attr {boolean} enable-tooltip - If `true`, a tooltip will be shown displaying the progress value.\n * @attr {boolean} enable-value-indicator - If `true` it will show the value label on the side of the slider track area.\n * @attr {number} gap - A number representing the amount to remain between the minimum and maximum values (only for range type).\n * @attr {number} max - A number representing the max value of the slider.\n * @attr {number} min - A number representing the min value of the slider.\n * @attr {number} step - A number represents the step of the slider. ⚠️ Please notice that the value (or list of values if the slider type is range) will be rounded to the nearest multiple of step.\n * @attr {boolean} tooltip-always-visible - If `true`, a tooltip will always display the progress value. It relies on enableTooltip and if enableTooltip is false, tooltipAlwaysVisible cannot be true.\n * @attr {\"range\" | \"single\"} type - It defines the type of slider to display.\n * @attr {\"[number, number]\" | \"number\" | \"string\"} value - The value of the slider. If the slider type is single, the value is a number.\n * If the slider type is range, the value is an array of two numbers (the first number represents the min value and the second number represents the max value).\n *\n * @event bqBlur - Handler to be called when the slider loses focus.\n * @event bqChange - Handler to be called when changing the value on range inputs.\n * @event bqFocus - Handler to be called when the slider gets focused.\n *\n * @part base - The component's base wrapper.\n * @part container - The container of the slider.\n * @part track-area - The track area of the slider.\n * @part progress-area - The progress area of the slider.\n * @part input-min - The input element for the value when the slider type is `single` or the minimum value when the slider type is `range`.\n * @part input-max - The input element for the maximum value.\n * @part label-start - The label for the value when the slider type is `single` or the minimum value when the slider type is `range`.\n * @part label-end - The label for maximum value when the slider type is `range`.\n *\n * @cssprop --bq-slider--size - The height of the slider track/progress area\n * @cssprop --bq-slider--border-radius - Slider border radius\n * @cssprop --bq-slider--thumb-size - Slider hover thumb size\n * @cssprop --bq-slider--progress-color - Slider progress background color\n * @cssprop --bq-slider--trackarea-color - Slider track background color\n */\n@Component({\n  tag: 'bq-slider',\n  styleUrl: './scss/bq-slider.scss',\n  formAssociated: true,\n  shadow: {\n    delegatesFocus: true,\n  },\n})\nexport class BqSlider {\n  // Own Properties\n  // ====================\n\n  private inputMinElem: HTMLInputElement;\n  private inputMaxElem: HTMLInputElement;\n  private minTooltipElem: HTMLBqTooltipElement;\n  private maxTooltipElem: HTMLBqTooltipElement;\n  private progressElem: HTMLSpanElement;\n  private trackElem: HTMLSpanElement;\n  private debounceBqChange: TDebounce<void>;\n\n  // Reference to host HTML element\n  // ===================================\n\n  @AttachInternals() internals!: ElementInternals;\n  @Element() el!: HTMLBqSliderElement;\n\n  // State() variables\n  // Inlined decorator, alphabetical order\n  // =======================================\n\n  /**\n   * The `minValue` state is the only value when the slider type is `single`\n   * and the minimum value when the slider type is `range`.\n   */\n  @State() minValue: number;\n  /** The `maxValue` state is only used when the slider type is `range`. */\n  @State() maxValue: number;\n  /** It hold the left position of the Thumb for the value or the minimum value (if the slider type is `range`) */\n  @State() minThumbPosition: number;\n  /** It hold the left position of the Thumb for the maximum value (if the slider type is `range`) */\n  @State() maxThumbPosition: number;\n\n  // Public Property API\n  // ========================\n\n  /** The amount of time, in milliseconds, to wait to trigger the `bqChange` event after each value change. */\n  @Prop({ reflect: true }) debounceTime = 0;\n\n  /** If `true` the slider is disabled. */\n  @Prop({ reflect: true }) disabled? = false;\n\n  /** If `true` it will show the value label on a side of the slider track area */\n  @Prop({ reflect: true }) enableValueIndicator? = false;\n\n  /** A number representing the amount to remain between the minimum and maximum values (only for range type). */\n  @Prop({ reflect: true, mutable: true }) gap = 0;\n\n  /** A number representing the max value of the slider. */\n  @Prop({ reflect: true }) max = 100;\n\n  /** A number representing the min value of the slider. */\n  @Prop({ reflect: true }) min = 0;\n\n  /** Name of the form control. Submitted with the form as part of a name/value pair */\n  @Prop({ reflect: true }) name: string;\n\n  /**\n   * A number representing the step of the slider.\n   * ⚠️ Please notice that the value (or list of values if the slider type is `range`) will be rounded to the nearest multiple of `step`.\n   */\n  @Prop({ reflect: true }) step = 1;\n\n  /** It defines the type of slider to display  */\n  @Prop({ reflect: true }) type: TSliderType = 'single';\n\n  /**\n   * The value of the slider.\n   * - If the slider type is `single`, the value is a number.\n   * - If the slider type is `range`, the value is an array of two numbers (the first number represents the `min` value and the second number represents the `max` value).\n   */\n  @Prop({ reflect: true, mutable: true }) value: TSliderValue;\n\n  /** If `true`, a tooltip will be shown displaying the progress value */\n  @Prop({ reflect: true }) enableTooltip: boolean = false;\n\n  /**\n   * If `true`, a tooltip will always display the progress value.\n   * It relies on enableTooltip and if enableTooltip is false, tooltipAlwaysVisible cannot be true.\n   */\n  @Prop({ reflect: true }) tooltipAlwaysVisible: boolean = false;\n\n  // Prop lifecycle events\n  // =======================\n\n  @Watch('value')\n  handleValuePropChange(newValue: TSliderValue) {\n    this.setState(newValue);\n    this.emitBqChange();\n  }\n\n  @Watch('step')\n  handleStepPropChange() {\n    this.minValue = Math.round(this.minValue / this.step) * this.step;\n    this.maxValue = Math.round(this.maxValue / this.step) * this.step;\n  }\n\n  @Watch('gap')\n  handleGapChange(newValue: number) {\n    if (!this.isRangeType) return;\n    // Use the this.value prop value when the component is initialized\n    // Otherwise, use the current this.min and this.max state values\n    const value = !isNil(this.min) && !isNil(this.max) ? [this.min, this.max] : this.stringToObject(this.value);\n    // If the gap is less than the min or greater than the max, set it to 0\n    this.gap = newValue < value[0] || newValue > value[1] ? 0 : newValue;\n  }\n\n  // Events section\n  // Requires JSDocs for public API documentation\n  // ==============================================\n\n  /** Handler to be called when change the value on range inputs */\n  @Event() bqChange: EventEmitter<{ value: Exclude<TSliderValue, string>; el: HTMLBqSliderElement }>;\n\n  /** Handler to be called when the slider loses focus */\n  @Event() bqBlur: EventEmitter<HTMLBqSliderElement>;\n\n  /** Handler to be called when the slider gets focused */\n  @Event() bqFocus: EventEmitter<HTMLBqSliderElement>;\n\n  // Component lifecycle events\n  // Ordered by their natural call order\n  // =====================================\n\n  componentWillLoad() {\n    this.init();\n  }\n\n  componentDidLoad() {\n    this.runUpdates();\n  }\n\n  componentDidUpdate() {\n    this.runUpdates();\n  }\n\n  formAssociatedCallback() {\n    this.internals?.setFormValue(`${this.value}`);\n  }\n\n  // Listeners\n  // ==============\n\n  // Public methods API\n  // These methods are exposed on the host element.\n  // Always use two lines.\n  // Public Methods must be async.\n  // Requires JSDocs for public API documentation.\n  // ===============================================\n\n  // Local methods\n  // Internal business logic.\n  // These methods cannot be called from the host element.\n  // =======================================================\n\n  private init = () => {\n    this.handleGapChange(this.gap);\n    this.setState(this.value);\n    this.handleStepPropChange();\n  };\n\n  private runUpdates = () => {\n    this.updateProgressTrack();\n    this.syncInputsValue();\n    this.setThumbPosition();\n  };\n\n  private setState = (newValue: TSliderValue) => {\n    const isRangeType = this.isRangeType;\n    const value = this.stringToObject(newValue);\n\n    this.minValue = isRangeType ? clamp(value[0], this.min, this.max - this.gap) : value;\n    this.maxValue = isRangeType ? clamp(value[1], this.minValue + this.gap, this.max) : this.minValue;\n  };\n\n  private setThumbPosition = () => {\n    if (!this.enableTooltip) return;\n\n    // Destructure the returned object from this.thumbPosition() and assign the properties to this.minThumbPosition and this.maxThumbPosition\n    ({ minThumbPosition: this.minThumbPosition, maxThumbPosition: this.maxThumbPosition } = this.thumbPosition());\n  };\n\n  private syncInputsValue = () => {\n    this.inputMinElem?.setAttribute('value', this.minValue.toString());\n    this.inputMaxElem?.setAttribute('value', this.maxValue.toString());\n  };\n\n  private stringToObject = (value: TSliderValue) => (isString(value) ? JSON.parse(value) : value);\n\n  private handleInputChange = (type: 'min' | 'max', event: InputEvent) => {\n    const target = event.target as HTMLInputElement;\n    const value = parseFloat(target.value);\n\n    if (type === 'min') {\n      this.minValue = this.isRangeType ? Math.min(value, this.maxValue - this.gap) : value;\n    } else if (type === 'max') {\n      this.maxValue = this.isRangeType ? Math.max(value, this.minValue + this.gap) : value;\n    }\n\n    // Update the input value to reflect the clamped value\n    const reflectedValue = (type === 'min' ? this.minValue : this.maxValue).toString();\n    target.value = reflectedValue;\n    target.setAttribute('value', reflectedValue);\n\n    // Sync the prop value.\n    // This will trigger the `@Watch('value')` method and emit the `bqChange` event.\n    const { internals, isRangeType, maxValue, minValue } = this;\n    this.value = isRangeType ? [minValue, maxValue] : minValue;\n    internals?.setFormValue(isRangeType ? JSON.stringify(this.value) : this.value.toString());\n  };\n\n  private calculatePercent = (value: number) => {\n    const totalRange = Number(this.max) - Number(this.min);\n    return (value / totalRange) * 100;\n  };\n\n  private updateProgressTrack = () => {\n    if (!this.progressElem) return;\n\n    // For range type, left starts from the `min` value and width is the difference between `max` and `min`.\n    // For non-range type, left starts from 0 and width is the `min` value.\n    const left = this.isRangeType ? this.calculatePercent(this.minValue) : 0;\n    const width = this.isRangeType\n      ? this.calculatePercent(Number(this.maxValue) - Number(this.minValue))\n      : this.calculatePercent(this.minValue);\n\n    this.progressElem.style.insetInlineStart = `${left}%`;\n    this.progressElem.style.inlineSize = `${width}%`;\n  };\n\n  private calculateThumbPosition = (value: number): number => {\n    if (!this.progressElem) return;\n\n    // Get the width of the track area and the size of the input range thumb\n    const trackAreaWidth = this.trackElem.getBoundingClientRect().width;\n    // We need to also add 4px to the thumb size,\n    // this is because the thumb is 2px border (`border-m`)\n    const inputThumbSize = parseInt(getComputedStyle(this.el).getPropertyValue('--bq-slider--thumb-size'), 10) + 4;\n    const totalWidth = trackAreaWidth - inputThumbSize;\n\n    return ((value - this.min) / (this.max - this.min)) * totalWidth + inputThumbSize / 2;\n  };\n\n  private thumbPosition = (): { minThumbPosition: number; maxThumbPosition?: number } => {\n    const minThumbPosition = this.calculateThumbPosition(this.minValue);\n    const maxThumbPosition = this.isRangeType ? this.calculateThumbPosition(this.maxValue) : undefined;\n\n    return { minThumbPosition, maxThumbPosition };\n  };\n\n  private emitBqChange = () => {\n    this.debounceBqChange?.cancel();\n\n    const value: Exclude<TSliderValue, string> = this.isRangeType ? [this.minValue, this.maxValue] : this.minValue;\n    this.debounceBqChange = debounce(() => this.bqChange.emit({ value, el: this.el }), this.debounceTime);\n\n    this.debounceBqChange();\n  };\n\n  private handleBlur = () => {\n    this.bqBlur.emit(this.el);\n  };\n\n  private handleFocus = () => {\n    this.bqFocus.emit(this.el);\n  };\n\n  private handleMouseDown = (event: MouseEvent) => {\n    this.handleTooltipVisibility(event, 'remove');\n  };\n\n  private handleMouseUp = (event: MouseEvent) => {\n    this.handleTooltipVisibility(event, 'add');\n  };\n\n  private handleTooltipVisibility = (event: MouseEvent, action: 'add' | 'remove') => {\n    if (!this.enableTooltip || this.tooltipAlwaysVisible) return;\n\n    const target = event.target as HTMLElement;\n    const tooltipElem = target === this.inputMinElem ? this.minTooltipElem : this.maxTooltipElem;\n    tooltipElem.classList[action]('hidden');\n  };\n\n  private get decimalCount(): number {\n    // Return the length of the decimal part of the step value.\n    return (this.step % 1).toFixed(10).split('.')[1].replace(/0+$/, '').length;\n  }\n\n  private get isRangeType() {\n    return this.type === 'range';\n  }\n\n  private get isTooltipAlwaysVisible(): boolean {\n    return this.tooltipAlwaysVisible && this.enableTooltip;\n  }\n\n  private renderLabel = (value: number, position: 'start' | 'end', css?: string) => {\n    return (\n      <span\n        class={{\n          [`${css} box-content block text-s font-medium leading-regular text-primary is-fit min-is-8 [font-variant:tabular-nums]`]:\n            true,\n          hidden: position === 'start' ? !this.enableValueIndicator : !this.enableValueIndicator || !this.isRangeType,\n        }}\n        part={`label-${position}`}\n      >\n        {value.toFixed(this.decimalCount)}\n      </span>\n    );\n  };\n\n  private renderInput = (type: 'max' | 'min', value: number, refCallback: (input: HTMLInputElement) => void) => {\n    // Determine the zIndex value based on the type and the current min and max values.\n    const zIndexValue = (type: 'min' | 'max'): string => {\n      const zIndex = {\n        min: this.minValue === this.min && this.maxValue === this.minValue,\n        max: this.maxValue === this.max && this.minValue === this.maxValue,\n      };\n\n      // If the value of both thumbs is the same as the min or max value, set the zIndex to -1\n      return zIndex[type] ? '-1' : '0';\n    };\n\n    return (\n      <input\n        type=\"range\"\n        class={{\n          'absolute start-0 -translate-y-1/2 cursor-pointer appearance-none bg-transparent outline-none is-full inset-bs-[50%] disabled:cursor-not-allowed':\n            true,\n          'pointer-events-none': this.isRangeType,\n        }}\n        style={this.isRangeType ? { zIndex: zIndexValue(type) } : undefined}\n        disabled={this.disabled}\n        min={this.min}\n        max={this.max}\n        name={this.name}\n        step={this.step}\n        ref={refCallback}\n        onInput={(ev) => this.handleInputChange(type, ev)}\n        onBlur={this.handleBlur}\n        onFocus={this.handleFocus}\n        onMouseDown={this.handleMouseDown}\n        onMouseUp={this.handleMouseUp}\n        value={value}\n        part={`input-${type}`}\n      />\n    );\n  };\n\n  private renderTooltip = (\n    value: number,\n    thumbPosition: number,\n    refCallback: (elem: HTMLBqTooltipElement) => void,\n  ): HTMLBqTooltipElement => (\n    <bq-tooltip\n      class={{\n        'absolute [&::part(panel)]:absolute': true,\n        hidden: !this.isTooltipAlwaysVisible,\n      }}\n      exportparts=\"base,trigger,panel\"\n      alwaysVisible={true}\n      distance={this.enableValueIndicator ? 6 : 16}\n      style={{ insetInlineStart: `${thumbPosition}px`, fontVariant: 'tabular-nums' }}\n      ref={refCallback}\n    >\n      <div class=\"absolute bs-1 is-1\" slot=\"trigger\" />\n      {value.toFixed(this.decimalCount)}\n    </bq-tooltip>\n  );\n\n  // render() function\n  // Always the last one in the class.\n  // ===================================\n\n  render() {\n    return (\n      <div\n        aria-disabled={this.disabled ? 'true' : 'false'}\n        class={{ 'flex is-full': true, 'cursor-not-allowed opacity-60': this.disabled }}\n        part=\"base\"\n      >\n        {/* LABEL (start) */}\n        {this.renderLabel(this.minValue, 'start', 'me-xs text-end')}\n        {/* SLIDER */}\n        <div class=\"relative is-full\" part=\"container\">\n          {/* TRACK AREA */}\n          <span\n            class=\"absolute start-0 -translate-y-1/2 rounded-xs bg-[--bq-slider--trackarea-color] bs-1 is-full inset-bs-[50%]\"\n            ref={(elem) => (this.trackElem = elem)}\n            part=\"track-area\"\n          />\n          {/* PROGRESS AREA */}\n          <span\n            class=\"absolute -translate-y-1/2 rounded-xs bg-[--bq-slider--progress-color] bs-1 is-[50%] inset-bs-[50%]\"\n            ref={(elem) => (this.progressElem = elem)}\n            part=\"progress-area\"\n          />\n          {/* TOOLTIP on top of the value or min value (if the slider type is `range`) */}\n          {this.enableTooltip &&\n            this.renderTooltip(this.minValue, this.minThumbPosition, (elem) => (this.minTooltipElem = elem))}\n          {/* INPUT (Min), used on single type */}\n          {this.renderInput('min', this.minValue, (input) => (this.inputMinElem = input))}\n          {/* TOOLTIP on top of the max value (if the slider type is `range`) */}\n          {this.enableTooltip &&\n            this.isRangeType &&\n            this.renderTooltip(this.maxValue, this.maxThumbPosition, (elem) => (this.maxTooltipElem = elem))}\n          {/* INPUT (Max) */}\n          {this.isRangeType && this.renderInput('max', this.maxValue, (input) => (this.inputMaxElem = input))}\n        </div>\n        {/* LABEL (end) */}\n        {this.renderLabel(this.maxValue, 'end', 'ms-xs text-start')}\n      </div>\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]}