{"file":"index-2193a099.js","mappings":"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","names":[],"sources":["../../packages/beeq/src/shared/utils/isClient.ts","../../packages/beeq/src/shared/utils/assetsPath.ts","../../packages/beeq/src/shared/utils/clamp.ts","../../packages/beeq/src/shared/utils/cssVariables.ts","../../packages/beeq/src/shared/utils/isNil.ts","../../packages/beeq/src/shared/utils/setRafTimeout.ts","../../packages/beeq/src/shared/utils/debounce.ts","../../packages/beeq/src/shared/utils/event.ts","../../packages/beeq/src/shared/utils/getNextElement.ts","../../packages/beeq/src/shared/utils/getRandom.ts","../../packages/beeq/src/shared/utils/isDefined.ts","../../packages/beeq/src/shared/utils/isEmpty.ts","../../packages/beeq/src/shared/utils/isHTMLElement.ts","../../packages/beeq/src/shared/utils/isString.ts","../../packages/beeq/src/shared/utils/props.ts","../../packages/beeq/src/shared/utils/slot.ts","../../packages/beeq/src/shared/utils/transition.ts"],"sourcesContent":["/**\n * Checks if the code is running on the client side.\n * @returns {boolean} True if running on the client side, false otherwise.\n */\nexport const isClient = (): boolean => {\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n};\n","/**\n * Inspired by Shoelace's `getBasePath` and `setBasePath` functions.\n * https://github.com/shoelace-style/shoelace/blob/next/src/utilities/base-path.ts\n */\nimport { Env } from '@stencil/core';\n\nimport { isClient } from './isClient';\n\nlet beeqBasePath: string | undefined;\nconst DATA_BEEQ_ATTRIBUTE = 'data-beeq';\nconst DEFAULT_SVG_PATH = 'svg';\n\n/**\n * Sets the base path for the assets.\n * @param {string} path - The base path to set.\n */\nexport const setBasePath = (path: string): void => {\n  beeqBasePath = path;\n};\n\n/**\n * Gets the base path for the assets.\n * @param {string} subpath - An optional subpath to append to the base path.\n * @returns {string} The base path of the assets.\n */\nexport const getBasePath = (subpath: string = ''): string => {\n  if (!beeqBasePath) {\n    const configScript = findConfigScript();\n    const fallbackScript = configScript ? null : findFallbackScript();\n\n    const script = configScript || fallbackScript;\n    if (script) {\n      const path = configScript ? script.getAttribute(DATA_BEEQ_ATTRIBUTE) : getScriptPath(script);\n      setBasePath(`${path}/${DEFAULT_SVG_PATH}`);\n    } else {\n      // Fallback: use an environment variable (if set) or the default path\n      setBasePath(Env.BEEQ_ASSETS_BASE_PATH || `./${DEFAULT_SVG_PATH}`);\n    }\n  }\n\n  // Return the base path without a trailing slash. If one exists, append the subpath separated by a slash.\n  const formattedSubpath = subpath ? `/${subpath.replace(/^\\//, '')}` : '';\n  return beeqBasePath.replace(/\\/$/, '') + formattedSubpath;\n};\n\n/**\n * Finds the configuration script element.\n * @returns The configuration script element or null if not found.\n */\nconst findConfigScript = (): HTMLScriptElement | null => {\n  if (!isClient()) return null;\n\n  return document.querySelector(`script[${DATA_BEEQ_ATTRIBUTE}]`);\n};\n\n/**\n * Finds the fallback script element.\n * @returns The fallback script element or null if not found.\n */\nconst findFallbackScript = (): HTMLScriptElement | null => {\n  if (!isClient()) return null;\n\n  return document.querySelector(`script[src*=\"beeq\"]`);\n};\n\n/**\n * Gets the path of a script element.\n * @param {HTMLScriptElement} script - The script element.\n * @returns The path of the script element.\n */\nconst getScriptPath = (script: HTMLScriptElement): string => {\n  if (!isClient()) return '';\n\n  const src = script.getAttribute('src');\n  return src ? src.substring(0, src.lastIndexOf('/')) : '';\n};\n","/**\n * Restricts value to a specified interval [min, max]\n *\n * @param value - value\n * @param min  - lower end of the interval\n * @param max  - upper end of the interval\n * @returns  - value in interval [min, max]\n */\nexport const clamp = (value: number, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER) => {\n  return Math.min(Math.max(min, value), max);\n};\n","import { isClient } from './isClient';\n\nconst CSSVALUEPREFIX = '--bq-';\n\n/**\n * Get CSS custom property variable of a given color string value\n *\n * @param {string} colorName - Valid string value.\n * @return {string} The corresponding CSS custom property variable\n */\nexport function getColorCSSVariable(colorName: string): string | undefined {\n  if (!isClient) return undefined;\n\n  const token = `${CSSVALUEPREFIX}${colorName}`;\n  const value = getComputedStyle(document.documentElement).getPropertyValue(token);\n  if (!value) return undefined;\n\n  return `var(${token})`;\n}\n\n/**\n * Get compiled CSS custom property value\n *\n * @param {string} variable - The variable name for which to get its value\n * @return {string} The corresponding value for the given CSS custom property\n */\nexport function getCSSVariableValue(variable: string, component: Element): string {\n  const styles = getComputedStyle(component);\n  return String(styles.getPropertyValue(`--${variable}`)).trim();\n}\n","/**\n * Check if the value is null or undefined\n * @param value the value to be checked\n * @returns {boolean} the value is null or undefined\n */\nexport const isNil = <T>(value: T): value is null | undefined => {\n  return value === null || value === undefined;\n};\n","/**\n * Implements setTimeout using requestAnimationFrame. Uses setTimeout if wait is 0.\n *\n * @param {Function} func - The function to timeout.\n * @param {Number} wait - The number of milliseconds to delay.\n * @param {Any[]} args - The arguments of func.\n * @returns {void}\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const setRafTimeout = <TFunc extends (...args: any[]) => void>(\n  func: TFunc,\n  wait: number,\n  ...args: Parameters<TFunc>\n): (() => void) => {\n  const invokeFunc = () => func(...args);\n\n  if (wait === 0) {\n    const timeoutId = setTimeout(invokeFunc, wait);\n    return () => clearTimeout(timeoutId);\n  } else {\n    let rafId: number;\n    const currentTime = performance.now();\n\n    const cancel = () => cancelAnimationFrame(rafId);\n\n    const handleRequestAnimationFrame: FrameRequestCallback = (time) => {\n      const delta = time - currentTime;\n\n      cancel();\n\n      if (delta < wait) {\n        rafId = requestAnimationFrame(handleRequestAnimationFrame);\n      } else {\n        invokeFunc();\n      }\n    };\n\n    rafId = requestAnimationFrame(handleRequestAnimationFrame);\n\n    return cancel;\n  }\n};\n","import { isNil } from './isNil';\nimport { setRafTimeout } from './setRafTimeout';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type TFunction = (...args: any[]) => unknown;\n\ntype TDebounceFnReturn<T> = T extends unknown[] ? (...params: T) => void : (param: T) => void;\nexport type TDebounce<T> = TDebounceFnReturn<T> & { cancel: () => void } extends infer U ? U : never;\n\n/**\n * Creates a debounced function that delays invoking func until after wait milliseconds have elapsed\n * since the last time the debounced function was invoked.\n *\n * @param {Function} func - The function to debounce.\n * @param {Number} wait - The number of milliseconds to delay.\n * @param {Boolean} immediate - If `true`, the function triggers immediately and then waits for the interval before being called again.\n * @return {Function} The new debounced function.\n */\nexport const debounce = <TFunc extends TFunction>(func: TFunc, wait = 0, immediate = false) => {\n  let cancel: () => void | undefined;\n\n  function debounceHandler(...args: Parameters<typeof func>) {\n    cancel?.();\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const context = this;\n\n    function timeoutHandler(fn: TFunc, context: unknown, ...args: Parameters<typeof fn>) {\n      fn.apply(context, args);\n    }\n\n    if (immediate && isNil(cancel)) {\n      func.apply(context, args);\n    }\n\n    cancel = setRafTimeout(timeoutHandler, wait, func, context, ...args);\n  }\n\n  return Object.assign(debounceHandler, {\n    cancel: () => {\n      cancel?.();\n    },\n  });\n};\n","/**\n * Check if the event target is a child of the host element\n * @param event - The event to check\n * @param hostElement - The host element to check against\n * @returns True if the event target is a child of the host element\n */\nexport const isEventTargetChildOfElement = (event: Event, hostElement: HTMLElement): boolean => {\n  const path = event.composedPath();\n\n  return path.includes(hostElement);\n};\n","/**\n * Gets the next element that is not disabled\n *\n * @param {Array} elements - The array to search in\n * @param {Numebr} startAt - Position to start at\n * @param {String} direction - The direction to look on\n * @returns {Element} Next available element\n */\n\nexport const getNextElement = <T extends { disabled: boolean }>(\n  elements: T[],\n  startAt = 0,\n  direction: 'forward' | 'backward' = 'forward',\n): T => {\n  let elementIndex = startAt;\n\n  do {\n    elementIndex = getNextIndex(elementIndex, elements.length, direction);\n    if (elementIndex === startAt) {\n      break;\n    }\n  } while (elements[elementIndex].disabled);\n\n  return elements[elementIndex];\n};\n\nconst getNextIndex = (currentIndex: number, length: number, direction: 'forward' | 'backward'): number => {\n  const nextIndex = currentIndex + (direction === 'forward' ? 1 : -1);\n  return (length + nextIndex) % length;\n};\n","/**\n * Get a number of randoms items from Array\n *\n * @param {Array} arr - The array where to look\n * @param {Number} n - The number of random items to take\n * @returns {Array} An array with the number of random items specified\n */\nexport const getRandomFromArray = <T>(arr: T[], n: number): T[] => {\n  let length = arr.length;\n  const result = new Array(n);\n  const taken = new Array(length);\n\n  if (n > length) throw new RangeError('getRandom: more elements taken than available');\n\n  while (n--) {\n    const x = Date.now() % length;\n    result[n] = arr[x in taken ? taken[x] : x];\n    taken[x] = --length in taken ? taken[length] : length;\n  }\n  return result;\n};\n","import { isString } from '.';\n\n/**\n * Check is a value is not falsy\n * @param value the value to be checked\n * @returns {boolean} the value is not falsy\n */\nexport const isDefined = (value: unknown): boolean => {\n  return isString(value) ? value.length !== 0 : Boolean(value);\n};\n","import { isDefined, isNil } from '.';\n\ntype TCollection = Map<unknown, unknown> | Array<unknown> | Record<string, unknown> | Set<unknown> | null | undefined;\n\n/**\n * Check if the value is an empty array, object, set, map\n * @param value the value to be checked\n * @returns {boolean} true if value is empty\n */\nexport const isEmpty = <T extends TCollection>(value: T): boolean => {\n  if (isNil(value)) {\n    return true;\n  } else if ('size' in value) {\n    return !isDefined(value.size);\n  } else {\n    return !isDefined(Object.values(value).length);\n  }\n};\n","/**\n * Check if value is the HTMLElement defined by tag\n * @param target the value to be check\n * @param tag valid HTMLElement\n * @returns {boolean} true if the target nodeName is the tag\n */\nexport const isHTMLElement = <T extends keyof HTMLElementTagNameMap = keyof HTMLElementTagNameMap>(\n  target: unknown,\n  tag: T,\n): target is HTMLElementTagNameMap[T] => {\n  return target instanceof Node && target.nodeName.toLowerCase() === tag;\n};\n","/**\n * Check if the value is a string or not\n * @param value the value to be checked\n * @returns {boolean} the value is a string\n */\nexport const isString = (value: unknown): value is string => {\n  const type = typeof value;\n  return (\n    type === 'string' ||\n    (type === 'object' &&\n      value != null &&\n      !Array.isArray(value) &&\n      Object.prototype.toString.call(value) == '[object String]')\n  );\n};\n","export type TExtractProp<T> = T[keyof T] extends infer U ? U : never;\nexport type TValidProperty<E, T> = TExtractProp<{ [K in keyof E]: E[K] extends T ? K : never }>;\n\n/**\n * Validate the element property value, if is one of the accepted values\n *\n * @param {readonly} ACCEPTED_VALUES - The list of the accepted values to check against.\n * @param {unknown} fallbackValue - The default value to assign\n * @param {Element} element - The component reference\n * @param {string} propertyName - The property name (will be used in the console notification)\n * @returns {void}\n */\nexport const validatePropValue = <T extends E[keyof E], E extends Element>(\n  ACCEPTED_VALUES: Readonly<T[]>,\n  fallbackValue: T,\n  element: E,\n  propertyName: TValidProperty<E, T>,\n): void => {\n  const propertyValue = element[propertyName as string];\n  // Early return if the property value is one of the accepted values\n  if (ACCEPTED_VALUES.includes(propertyValue)) return;\n  // Override property with fallback value\n  element[propertyName as string] = fallbackValue;\n  // Notify developer in the browser console\n  console.warn(\n    `[${element.tagName.toUpperCase()}] Please notice that \"${String(\n      propertyName,\n    )}\" should be one of ${ACCEPTED_VALUES.join('|')}`,\n  );\n};\n","/*=========================================================================================\n= Credit:                                                                                =\n= https://github.com/shoelace-style/shoelace/blob/next/src/utilities/slot.ts             =\n=========================================================================================*/\n\nfunction isElementNode(node: Node): node is HTMLElement {\n  return node.nodeType === Node.ELEMENT_NODE;\n}\n\nfunction isTextNode(node: Node): node is Text {\n  return node.nodeType === Node.TEXT_NODE;\n}\n\nfunction getText(node: Node, currentLevel = 1, maxLevel = Infinity): string {\n  let text = '';\n  if (currentLevel <= maxLevel) {\n    if (isTextNode(node)) {\n      text += node.textContent;\n    } else if (isElementNode(node) && node.hasChildNodes()) {\n      const nextLevel = currentLevel + 1;\n      node.childNodes.forEach((node) => {\n        text += getText(node, nextLevel, maxLevel);\n      });\n    }\n  }\n\n  return text;\n}\n\nexport interface IOptions {\n  recurse: boolean;\n  maxLevel?: number;\n}\n\n/**\n * Iterates over all of its assigned element and text nodes of a given slot and returns the concatenated HTML as a string.\n *\n * @param {HTMLSlotElement} slot - Slot HTML element\n * @return {string} The concatenated HTML as a string\n */\nexport function getInnerHTML(slot: HTMLSlotElement): string {\n  const nodes = slot.assignedNodes({ flatten: true });\n  let html = '';\n\n  [...nodes].forEach((node) => {\n    if (isElementNode(node)) {\n      html += node.outerHTML;\n    }\n\n    if (isTextNode(node)) {\n      html += node.textContent;\n    }\n  });\n\n  return html;\n}\n\n/**\n * Iterates over all of its assigned text nodes of a given slot and returns the concatenated text as a string.\n *\n * @param {HTMLSlotElement} slot - Slot HTML element\n * @return {string} The concatenated text as a string\n */\nexport function getTextContent(slot: HTMLSlotElement): string;\n/**\n * Iterates over all of its assigned text nodes of a given slot and returns the concatenated text as a string.\n *\n * @param {HTMLSlotElement} slot - Slot HTML element\n * @param {IOptions} options - Options to retrieve text\n * @return {string} The concatenated text as a string\n */\nexport function getTextContent(slot: HTMLSlotElement, options: IOptions): string;\nexport function getTextContent(slot: HTMLSlotElement, options?: IOptions): string {\n  const nodes = slot.assignedNodes({ flatten: true });\n  const { recurse = false, maxLevel } = options ?? {};\n  let text = '';\n\n  [...nodes].forEach((node) => {\n    text += getText(node, 1, recurse ? maxLevel : 1);\n  });\n\n  return text.trim();\n}\n\n/**\n * Determines whether a slot with the given name exists in an element.\n *\n * @param {HTMLElement} el - The HTMl element to check\n * @param {string} name - Name of the slot to check inside the HTML element\n * @return {boolean} True or false if the given HTML element has slot\n */\nexport function hasSlot(el: HTMLElement, name: string): boolean {\n  return (\n    Array.from(el.querySelectorAll('[slot]')).filter((slottedEl: HTMLSlotElement) => slottedEl.slot === name).length > 0\n  );\n}\n\n/**\n * Will return whether if a given slot have HTML children elements or not.\n *\n * @param {HTMLElement} el - The HTML element that holds the slot\n * @param {string} [name] - Optional slot name\n * @return {boolean} True or false if the slot have HTML children elements\n */\nexport function hasSlotContent(el: HTMLElement, name?: string): boolean {\n  const slotSelector = name ? `[name='${name}']` : '';\n  const slotContent = el.querySelector<HTMLSlotElement>(`slot${slotSelector}`)?.assignedElements({ flatten: true });\n  if (!slotContent || !Array.isArray(slotContent)) return false;\n\n  return !!slotContent.length;\n}\n","/* -------------------------------------------------------------------------- */\n/*            Credits to MikeMcCall for the original implementation           */\n/*            Github: https://github.com/mmccall10/el-transition              */\n/* -------------------------------------------------------------------------- */\n\ninterface HTMLElementWithAnimations extends HTMLElement {\n  getAnimations(): Animation[];\n}\n\n/**\n * Transition an element entry\n *\n * @param element The element to enter\n * @param transitionName The name of the transition\n * @returns A promise that resolves when the transition is complete\n */\nexport const enter = async (element: HTMLElement, transitionName: string | null = null): Promise<void> => {\n  element.classList.remove('hidden');\n  await transition('enter', element, transitionName);\n};\n\n/**\n * Transition an element exit\n *\n * @param element The element to leave\n * @param transitionName The name of the transition\n * @returns A promise that resolves when the transition is complete\n */\nexport const leave = async (element: HTMLElement, transitionName: string | null = null): Promise<void> => {\n  await transition('leave', element, transitionName);\n  element.classList.add('hidden');\n};\n\n/**\n * Toggle an element entry/exit\n *\n * @param element The element to toggle\n * @param transitionName The name of the transition\n * @returns A promise that resolves when the transition is complete\n */\nexport const toggle = async (element: HTMLElement, transitionName: string | null = null): Promise<void> => {\n  if (element.classList.contains('hidden')) {\n    await enter(element, transitionName);\n  } else {\n    await leave(element, transitionName);\n  }\n};\n\n/**\n * Perform a transition on an element\n *\n * @param direction The direction of the transition\n * @param element The element to transition\n * @param animation The animation to use\n * @returns A promise that resolves when the transition is complete\n * @internal\n */\nconst transition = async (direction: string, element: HTMLElement, animation: string | null): Promise<void> => {\n  const { dataset } = element;\n  const animationClass = animation ? `${animation}-${direction}` : direction;\n  const transitionKey = `transition${direction.charAt(0).toUpperCase() + direction.slice(1)}`;\n\n  // Get the genesis, start, and end classes\n  const genesisClasses = getDatasetValueOrDefault(dataset, transitionKey, animationClass);\n  const startClasses = getDatasetValueOrDefault(dataset, `${transitionKey}Start`, `${animationClass}-start`);\n  const endClasses = getDatasetValueOrDefault(dataset, `${transitionKey}End`, `${animationClass}-end`);\n\n  // Add genesis and start classes, then wait for the next frame\n  addClasses(element, genesisClasses);\n  addClasses(element, startClasses);\n  await nextFrame();\n\n  // Replace start classes with end classes, then wait for the transition to finish\n  removeClasses(element, startClasses);\n  addClasses(element, endClasses);\n  await afterTransition(element as HTMLElementWithAnimations);\n\n  // Remove end and genesis classes\n  removeClasses(element, endClasses);\n  removeClasses(element, genesisClasses);\n};\n\n/**\n * Get the value of a dataset key or a default value\n *\n * @param dataset The dataset to get the value from\n * @param key The key to get the value for\n * @param defaultValue The default value to return if the key is not found\n * @returns The value of the dataset key or the default value\n * @internal\n */\nconst getDatasetValueOrDefault = (dataset: DOMStringMap, key: string, defaultValue: string): string[] => {\n  return dataset[key] ? dataset[key].split(' ') : [defaultValue];\n};\n\n/**\n * Add classes to an element\n *\n * @param element The element to add the CSS classes to\n * @param classes The classes to add\n * @internal\n */\nconst addClasses = (element: HTMLElement, classes: string[]): void => {\n  element.classList.add(...classes);\n};\n\n/**\n * Remove classes from an element\n *\n * @param element The element to remove the CSS classes from\n * @param classes The classes to remove\n * @internal\n */\nconst removeClasses = (element: HTMLElement, classes: string[]): void => {\n  element.classList.remove(...classes);\n};\n\n/**\n * Wait for the next frame\n * @returns A promise that resolves when the next frame is available\n * @internal\n */\nconst nextFrame = (): Promise<void> => {\n  return new Promise((resolve) => {\n    requestAnimationFrame(() => {\n      requestAnimationFrame(() => resolve());\n    });\n  });\n};\n\n/**\n * Wait for all animations to finish\n * @param element The element to wait for\n * @returns A promise that resolves when all animations are finished\n * @internal\n */\nconst afterTransition = (element: HTMLElementWithAnimations): Promise<Animation[]> => {\n  return Promise.all(element.getAnimations().map((animation) => animation.finished));\n};\n"],"version":3}