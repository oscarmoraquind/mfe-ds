{"version":3,"names":["isElementNode","node","nodeType","Node","ELEMENT_NODE","isTextNode","TEXT_NODE","getText","currentLevel","maxLevel","Infinity","text","textContent","hasChildNodes","nextLevel","childNodes","forEach","getInnerHTML","slot","nodes","assignedNodes","flatten","html","outerHTML","getTextContent","options","recurse","trim","hasSlot","el","name","Array","from","querySelectorAll","filter","slottedEl","length","hasSlotContent","slotSelector","slotContent","querySelector","assignedElements","isArray"],"sources":["../../packages/beeq/src/shared/utils/slot.ts"],"sourcesContent":["/*=========================================================================================\n= Credit:                                                                                =\n= https://github.com/shoelace-style/shoelace/blob/next/src/utilities/slot.ts             =\n=========================================================================================*/\n\nfunction isElementNode(node: Node): node is HTMLElement {\n  return node.nodeType === Node.ELEMENT_NODE;\n}\n\nfunction isTextNode(node: Node): node is Text {\n  return node.nodeType === Node.TEXT_NODE;\n}\n\nfunction getText(node: Node, currentLevel = 1, maxLevel = Infinity): string {\n  let text = '';\n  if (currentLevel <= maxLevel) {\n    if (isTextNode(node)) {\n      text += node.textContent;\n    } else if (isElementNode(node) && node.hasChildNodes()) {\n      const nextLevel = currentLevel + 1;\n      node.childNodes.forEach((node) => {\n        text += getText(node, nextLevel, maxLevel);\n      });\n    }\n  }\n\n  return text;\n}\n\nexport interface IOptions {\n  recurse: boolean;\n  maxLevel?: number;\n}\n\n/**\n * Iterates over all of its assigned element and text nodes of a given slot and returns the concatenated HTML as a string.\n *\n * @param {HTMLSlotElement} slot - Slot HTML element\n * @return {string} The concatenated HTML as a string\n */\nexport function getInnerHTML(slot: HTMLSlotElement): string {\n  const nodes = slot.assignedNodes({ flatten: true });\n  let html = '';\n\n  [...nodes].forEach((node) => {\n    if (isElementNode(node)) {\n      html += node.outerHTML;\n    }\n\n    if (isTextNode(node)) {\n      html += node.textContent;\n    }\n  });\n\n  return html;\n}\n\n/**\n * Iterates over all of its assigned text nodes of a given slot and returns the concatenated text as a string.\n *\n * @param {HTMLSlotElement} slot - Slot HTML element\n * @return {string} The concatenated text as a string\n */\nexport function getTextContent(slot: HTMLSlotElement): string;\n/**\n * Iterates over all of its assigned text nodes of a given slot and returns the concatenated text as a string.\n *\n * @param {HTMLSlotElement} slot - Slot HTML element\n * @param {IOptions} options - Options to retrieve text\n * @return {string} The concatenated text as a string\n */\nexport function getTextContent(slot: HTMLSlotElement, options: IOptions): string;\nexport function getTextContent(slot: HTMLSlotElement, options?: IOptions): string {\n  const nodes = slot.assignedNodes({ flatten: true });\n  const { recurse = false, maxLevel } = options ?? {};\n  let text = '';\n\n  [...nodes].forEach((node) => {\n    text += getText(node, 1, recurse ? maxLevel : 1);\n  });\n\n  return text.trim();\n}\n\n/**\n * Determines whether a slot with the given name exists in an element.\n *\n * @param {HTMLElement} el - The HTMl element to check\n * @param {string} name - Name of the slot to check inside the HTML element\n * @return {boolean} True or false if the given HTML element has slot\n */\nexport function hasSlot(el: HTMLElement, name: string): boolean {\n  return (\n    Array.from(el.querySelectorAll('[slot]')).filter((slottedEl: HTMLSlotElement) => slottedEl.slot === name).length > 0\n  );\n}\n\n/**\n * Will return whether if a given slot have HTML children elements or not.\n *\n * @param {HTMLElement} el - The HTML element that holds the slot\n * @param {string} [name] - Optional slot name\n * @return {boolean} True or false if the slot have HTML children elements\n */\nexport function hasSlotContent(el: HTMLElement, name?: string): boolean {\n  const slotSelector = name ? `[name='${name}']` : '';\n  const slotContent = el.querySelector<HTMLSlotElement>(`slot${slotSelector}`)?.assignedElements({ flatten: true });\n  if (!slotContent || !Array.isArray(slotContent)) return false;\n\n  return !!slotContent.length;\n}\n"],"mappings":";;;;AAKA,SAASA,EAAcC,GACrB,OAAOA,EAAKC,WAAaC,KAAKC,YAChC,CAEA,SAASC,EAAWJ,GAClB,OAAOA,EAAKC,WAAaC,KAAKG,SAChC,CAEA,SAASC,EAAQN,EAAYO,EAAe,EAAGC,EAAWC,UACxD,IAAIC,EAAO,GACX,GAAIH,GAAgBC,EAAU,CAC5B,GAAIJ,EAAWJ,GAAO,CACpBU,GAAQV,EAAKW,W,MACR,GAAIZ,EAAcC,IAASA,EAAKY,gBAAiB,CACtD,MAAMC,EAAYN,EAAe,EACjCP,EAAKc,WAAWC,SAASf,IACvBU,GAAQJ,EAAQN,EAAMa,EAAWL,EAAS,G,EAKhD,OAAOE,CACT,C,SAagBM,EAAaC,GAC3B,MAAMC,EAAQD,EAAKE,cAAc,CAAEC,QAAS,OAC5C,IAAIC,EAAO,GAEX,IAAIH,GAAOH,SAASf,IAClB,GAAID,EAAcC,GAAO,CACvBqB,GAAQrB,EAAKsB,S,CAGf,GAAIlB,EAAWJ,GAAO,CACpBqB,GAAQrB,EAAKW,W,KAIjB,OAAOU,CACT,C,SAiBgBE,EAAeN,EAAuBO,GACpD,MAAMN,EAAQD,EAAKE,cAAc,CAAEC,QAAS,OAC5C,MAAMK,QAAEA,EAAU,MAAKjB,SAAEA,GAAagB,GAAW,GACjD,IAAId,EAAO,GAEX,IAAIQ,GAAOH,SAASf,IAClBU,GAAQJ,EAAQN,EAAM,EAAGyB,EAAUjB,EAAW,EAAE,IAGlD,OAAOE,EAAKgB,MACd,C,SASgBC,EAAQC,EAAiBC,GACvC,OACEC,MAAMC,KAAKH,EAAGI,iBAAiB,WAAWC,QAAQC,GAA+BA,EAAUjB,OAASY,IAAMM,OAAS,CAEvH,C,SASgBC,EAAeR,EAAiBC,GAC9C,MAAMQ,EAAeR,EAAO,UAAUA,MAAW,GACjD,MAAMS,EAAcV,EAAGW,cAA+B,OAAOF,MAAiBG,iBAAiB,CAAEpB,QAAS,OAC1G,IAAKkB,IAAgBR,MAAMW,QAAQH,GAAc,OAAO,MAExD,QAASA,EAAYH,MACvB,Q","ignoreList":[]}